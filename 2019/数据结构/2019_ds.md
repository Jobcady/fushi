# 数据结构
#### 1. 有集合a和集合b，设计两种算法实现a并b
1. 简述设计思想；

2. 用什么数据结构，为什么；

3. 用什么存储结构，为什么；

4. 写出具体算法，计算时间复杂度。

#### 答：
1. 用一个单链表(线性表)来表示集合a，用另一个单链表(线性表)来表示集合b，遍历链表，若b中元素在a中没有，则将此元素加入到链表a中，直到遍历结束。

2. 线性表，因为数据元素之间存在一对一的线性关系；

3. 顺序表，因为顺序表可以随机存取，也可以顺序存取；

4. 设计思路：利用两个线性表LA和LB分别表示两个集合A和B，即线性表中的数据元素即为集合中的成员，现要求得到一个新的集合A=A∪B，则线性表如下操作：扩大线性表LA，将存在于线性表LB中而不存在于线性表LA中的数据元素插入到LA中，只需从线性表LB中依次取得每个数据元素，并在LA中查询，若不存在，则插入。
- 具体算法：
```C
typedef struct LNode
{
    ElemType data;      //数据类型
    struct LNode *next; //指针
} LNode, *LinkList;

void Union(LinkList &LA, LinkList LB)
{
    int i;

    LA_len = ListLength(LA); //表长
    LB_len = ListLength(LB);
    for (i = 1; i < LB_len; i++)
    {
        e = getElem(LB, i, e);
        if (!locateElem(LA, e, equal))
            ListInsert(LA, ++LA_len, e);
    }
}
```
#### 2. 什么是哈夫曼树？举两个应用例子说明。
哈夫曼树是给定n个权值作为n个叶子结点，构造一棵二叉树，若该数的带权路径长度达到最小，称这样的二叉树为最优二叉树，也成为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。  
例子：  
1. 将w<sub>1</sub>、w<sub>2</sub>、...  w<sub>n</sub>看成是有n棵树的森林(每棵树仅有一个结点)；  
2. 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左右子树，且新树的根结点权值为其左、右子树根结点权值之和；  
3. 从森林中删除选取的两棵树，并将新树加入森林；  
4. 重复2、3步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。  
#### 3.举例说明图的四种结构(可以结合算法和图示来讨论)